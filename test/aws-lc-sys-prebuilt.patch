--- a/builder/main.rs
+++ b/builder/main.rs
@@ -10,6 +10,7 @@
 #![cfg_attr(clippy, feature(custom_inner_attributes))]
 #![cfg_attr(clippy, clippy::msrv = "1.77")]
 
+use std::collections::HashSet;
 use std::ffi::{OsStr, OsString};
 use std::fmt::Debug;
 use std::path::{Path, PathBuf};
@@ -242,9 +243,102 @@
         } else {
             name.to_string()
         }
+    }
+}
+
+#[derive(Clone)]
+struct PrebuiltLibrary {
+    path: PathBuf,
+    link_name: String,
+    link_type: OutputLibType,
+}
+
+#[derive(Clone)]
+struct PrebuiltLibraries {
+    crypto: PrebuiltLibrary,
+    ssl: Option<PrebuiltLibrary>,
+}
+
+impl PrebuiltLibraries {
+    fn iter(&self) -> impl Iterator<Item = &PrebuiltLibrary> {
+        std::iter::once(&self.crypto).chain(self.ssl.as_ref())
+    }
+
+    fn link_names(&self) -> (String, Option<String>) {
+        (
+            self.crypto.link_name.clone(),
+            self.ssl.as_ref().map(|lib| lib.link_name.clone()),
+        )
+    }
+}
+
+impl PrebuiltLibrary {
+    fn new(path: PathBuf) -> Result<Self, String> {
+        let canonical_path = dunce::canonicalize(&path).unwrap_or(path.clone());
+        let link_type = match canonical_path.extension().and_then(|ext| ext.to_str()) {
+            Some("a") | Some("lib") => OutputLibType::Static,
+            Some("dll") | Some("dylib") | Some("so") => OutputLibType::Dynamic,
+            Some(other) => {
+                emit_warning(format!(
+                    "Unrecognized library extension '{other}', assuming static"
+                ));
+                OutputLibType::Static
+            }
+            None => OutputLibType::Static,
+        };
+        let stem = canonical_path
+            .file_stem()
+            .ok_or_else(|| format!("Missing library file name for {}", path.display()))?
+            .to_string_lossy()
+            .into_owned();
+        let link_name = stem.trim_start_matches("lib").to_string();
+        Ok(Self {
+            path: canonical_path,
+            link_name,
+            link_type,
+        })
     }
+
+    fn link_dir(&self) -> Option<PathBuf> {
+        self.path.parent().map(Path::to_path_buf)
+    }
 }
 
+struct PrebuiltBuilder {
+    manifest_dir: PathBuf,
+    out_dir: PathBuf,
+    build_prefix: Option<String>,
+    libraries: PrebuiltLibraries,
+}
+
+impl PrebuiltBuilder {
+    fn new(
+        manifest_dir: PathBuf,
+        out_dir: PathBuf,
+        build_prefix: Option<String>,
+        libraries: PrebuiltLibraries,
+    ) -> Self {
+        Self {
+            manifest_dir,
+            out_dir,
+            build_prefix,
+            libraries,
+        }
+    }
+
+    fn build_rust_wrapper(&self) {
+        // aws-lc-sys 0.37.0 does not include rust_wrapper.c.
+    }
+}
+
 const VERSION: &str = env!("CARGO_PKG_VERSION");
 
 fn prefix_string() -> String {
@@ -404,6 +498,70 @@
     std::env::current_dir().unwrap()
 }
 
+fn select_prebuilt_path(var: &str, value: &str) -> Result<PathBuf, String> {
+    let expected = if var.contains("CRYPTO") { "crypto" } else { "ssl" };
+    let mut fallback: Option<PathBuf> = None;
+
+    for entry in value.split_whitespace() {
+        let path = PathBuf::from(entry);
+        if fallback.is_none() {
+            fallback = Some(path.clone());
+        }
+        let file_stem = path.file_stem().and_then(|stem| stem.to_str());
+        let normalized = file_stem.map(|stem| stem.trim_start_matches("lib"));
+        let is_expected = normalized.map_or(false, |stem| stem == expected);
+        let is_pic = entry.contains(".pic.");
+        if is_expected && !is_pic {
+            return Ok(path);
+        }
+    }
+
+    fallback.ok_or_else(|| {
+        format!("AWS_LC_SYS_{var} did not contain any usable library paths: {value}")
+    })
+}
+
+fn prebuilt_library_from_env(var: &str) -> Option<PrebuiltLibrary> {
+    optional_env_crate_target(var).map(|value| {
+        let path = select_prebuilt_path(var, &value).unwrap_or_else(|err| panic!("{err}"));
+        PrebuiltLibrary::new(path).unwrap_or_else(|err| panic!("{err}"))
+    })
+}
+
+fn detect_prebuilt_libraries() -> Option<PrebuiltLibraries> {
+    let crypto = prebuilt_library_from_env("PREBUILT_CRYPTO");
+    let ssl = prebuilt_library_from_env("PREBUILT_SSL");
+
+    if crypto.is_none() && ssl.is_none() {
+        return None;
+    }
+
+    let crypto = crypto.unwrap_or_else(|| {
+        panic!(
+            "AWS_LC_SYS_PREBUILT_SSL is set without AWS_LC_SYS_PREBUILT_CRYPTO. \
+Provide both or unset to fall back to building AWS-LC from source."
+        )
+    });
+
+    if cfg!(feature = "ssl") {
+        let ssl = ssl.unwrap_or_else(|| {
+            panic!(
+                "Feature 'ssl' is enabled, but AWS_LC_SYS_PREBUILT_SSL is not set. \
+Provide both AWS_LC_SYS_PREBUILT_CRYPTO and AWS_LC_SYS_PREBUILT_SSL to use prebuilt libraries."
+            )
+        });
+        Some(PrebuiltLibraries {
+            crypto,
+            ssl: Some(ssl),
+        })
+    } else {
+        Some(PrebuiltLibraries {
+            crypto,
+            ssl: None,
+        })
+    }
+}
+
 fn get_builder(prefix: &Option<String>, manifest_dir: &Path, out_dir: &Path) -> Box<dyn Builder> {
     let cmake_builder_builder = || {
         Box::new(CmakeBuilder::new(
@@ -452,6 +610,53 @@
     fn name(&self) -> &str;
 }
 
+impl Builder for PrebuiltBuilder {
+    fn check_dependencies(&self) -> Result<(), String> {
+        for lib in self.libraries.iter() {
+            if !lib.path.is_file() {
+                return Err(format!(
+                    "Prebuilt AWS-LC library not found at {}",
+                    lib.path.display()
+                ));
+            }
+        }
+        Ok(())
+    }
+
+    fn build(&self) -> Result<(), String> {
+        let mut search_paths = HashSet::new();
+        for lib in self.libraries.iter() {
+            if let Some(dir) = lib.link_dir() {
+                if search_paths.insert(dir.clone()) {
+                    println!("cargo:rustc-link-search=native={}", dir.display());
+                }
+            }
+            println!(
+                "cargo:rustc-link-lib={}={}",
+                lib.link_type.rust_lib_type(),
+                lib.link_name
+            );
+        }
+
+        Ok(())
+    }
+
+    fn name(&self) -> &str {
+        "prebuilt"
+    }
+}
+
 #[derive(Clone, Copy, Debug, PartialEq, Eq)]
 pub(crate) enum CStdRequested {
     C99,
@@ -690,14 +895,26 @@
 
     let manifest_dir = current_dir();
     let manifest_dir = dunce::canonicalize(Path::new(&manifest_dir)).unwrap();
+    let out_dir = out_dir();
     let prefix_str = prefix_string();
-    let prefix = if is_no_prefix() {
+    let prebuilt_libraries = detect_prebuilt_libraries();
+    let prefix = if is_no_prefix() || prebuilt_libraries.is_some() {
         None
     } else {
         Some(prefix_str)
     };
 
-    let builder = get_builder(&prefix, &manifest_dir, &out_dir());
+    let builder: Box<dyn Builder> = if let Some(ref libraries) = prebuilt_libraries {
+        emit_warning("Using prebuilt AWS-LC libraries provided via AWS_LC_SYS_PREBUILT_*");
+        Box::new(PrebuiltBuilder::new(
+            manifest_dir.clone(),
+            out_dir.clone(),
+            prefix.clone(),
+            libraries.clone(),
+        ))
+    } else {
+        get_builder(&prefix, &manifest_dir, &out_dir)
+    };
     emit_warning(format!("Building with: {}", builder.name()));
     emit_warning(format!("Symbol Prefix: {:?}", &prefix));
 
@@ -754,7 +971,7 @@
                 "External bindgen required, but external bindgen unable to produce SSL bindings.",
             );
         } else {
-            let gen_bindings_path = out_dir().join("bindings.rs");
+            let gen_bindings_path = out_dir.join("bindings.rs");
             let result = invoke_external_bindgen(&manifest_dir, &prefix, &gen_bindings_path);
             match result {
                 Ok(()) => {
@@ -775,13 +992,25 @@
 
     println!(
         "cargo:include={}",
-        setup_include_paths(&out_dir(), &manifest_dir).display()
+        setup_include_paths(&out_dir, &manifest_dir).display()
     );
 
     // export the artifact names
-    println!("cargo:libcrypto={}_crypto", prefix_string());
-    if cfg!(feature = "ssl") {
-        println!("cargo:libssl={}_ssl", prefix_string());
+    let (libcrypto_name, libssl_name) = if let Some(ref libraries) = prebuilt_libraries {
+        libraries.link_names()
+    } else {
+        (
+            OutputLib::Crypto.libname(&prefix),
+            if cfg!(feature = "ssl") {
+                Some(OutputLib::Ssl.libname(&prefix))
+            } else {
+                None
+            },
+        )
+    };
+    println!("cargo:libcrypto={}", libcrypto_name);
+    if let Some(name) = libssl_name {
+        println!("cargo:libssl={name}");
     }
 
     println!("cargo:conf={}", OSSL_CONF_DEFINES.join(","));
